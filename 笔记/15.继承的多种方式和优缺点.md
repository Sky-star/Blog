# 实现集成的方式

- 原型链继承

即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针

```js
function Parent() {
	this.name = "parent1"
	this.play = [1, 2, 3]
}
function Child() {
	this.type = "child2"
}
Child1.prototype = new Parent()
console.log(new Child())
```

```js
var s1 = new Child2()
var s2 = new Child2()
s1.play.push(4)
console.log(s1.play, s2.play) // [1,2,3,4]
```

缺点: 两个实例对象会指向同一原型对象, 内存空间共享

- 构造函数继承

```js
function Parent() {
	this.name = "parent1"
}

Parent.prototype.getName = function () {
	return this.name
}

function Child() {
	Parent1.call(this)
	this.type = "child"
}

let child = new Child()
console.log(child) // 没问题
console.log(child.getName()) // 会报错
```

缺点: 只能继承父类本身的属性和方法，不能继承原型属性或者方法

- 组合继承

将原型链继承和构造函数继承组合起来

```js
function Parent3() {
	this.name = "parent3"
	this.play = [1, 2, 3]
}

Parent3.prototype.getName = function () {
	return this.name
}
function Child3() {
	// 第二次调用 Parent3()
	Parent3.call(this)
	this.type = "child3"
}

// 第一次调用 Parent3()
Child3.prototype = new Parent3()
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3
var s3 = new Child3()
var s4 = new Child3()
s3.play.push(4)
console.log(s3.play, s4.play) // 不互相影响
console.log(s3.getName()) // 正常输出'parent3'
console.log(s4.getName()) // 正常输出'parent3'
```

缺点: 会造成构造函数执行两次的问题， 多一次性能的开销

- 原型式继承

这里主要借助 Object.create 方法实现普通对象的继承

```js
let parent4 = {
	name: "parent4",
	friends: ["p1", "p2", "p3"],
	getName: function () {
		return this.name
	}
}

let person4 = Object.create(parent4)
person4.name = "tom"
person4.friends.push("jerry")

let person5 = Object.create(parent4)
person5.friends.push("lucy")

console.log(person4.name) // tom
console.log(person4.name === person4.getName()) // true
console.log(person5.name) // parent4
console.log(person4.friends) // ["p1", "p2", "p3","jerry","lucy"]
console.log(person5.friends) // ["p1", "p2", "p3","jerry","lucy"]
```

缺点: Object.create()实际是浅拷贝， 多个实例对象的引用对象会指向同一个地址

- 寄生式集成

寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法

```js
let parent5 = {
	name: "parent5",
	friends: ["p1", "p2", "p3"],
	getName: function () {
		return this.name
	}
}

function clone(original) {
	let clone = Object.create(original)
	clone.getFriends = function () {
		return this.friends
	}
	return clone
}

let person5 = clone(parent5)

console.log(person5.getName()) // parent5
console.log(person5.getFriends()) // ["p1", "p2", "p3"]
```

- 寄生组合式集成
  MDN 上的继承方式

```js
// Shape - superclass
function Shape() {
	this.x = 0
	this.y = 0
}

// superclass method
Shape.prototype.move = function (x, y) {
	this.x += x
	this.y += y
	console.info("Shape moved.")
}

// Rectangle - subclass
function Rectangle() {
	Shape.call(this) // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype)

//If you don't set Rectangle.prototype.constructor to Rectangle,
//it will take the prototype.constructor of Shape (parent).
//To avoid that, we set the prototype.constructor to Rectangle (child).
Rectangle.prototype.constructor = Rectangle

const rect = new Rectangle()

console.log("Is rect an instance of Rectangle?", rect instanceof Rectangle) // true
console.log("Is rect an instance of Shape?", rect instanceof Shape) // true
rect.move(1, 1) // Outputs, 'Shape moved.'
```
