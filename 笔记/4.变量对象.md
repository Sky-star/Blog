# 前言

接着上面的执行上下文，当遇到一段可执行代码的时候，会创建对应的执行上下文，并压入执行上下文栈中。

每个执行上下文都有三个**重要**的属性

- 变量对象(Variable Object, VO)
- 作用域连(Scope Chain)
- this

# 变量对象

定义: 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

简单来说一段执行上下文中，变量对象存储了作用域内的变量和函数，就是为了方便查找使用的。

> 不同执行上下文的变量对象稍有不同。 主要了解下**全局上下文**和**函数上下文**的变量对象。

# 全局上下文

全局对象:

> 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。

> 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。

> 例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。

**分析**

1. 在客户端 JavaScript 中 `this == window // true`
2. 全局对象 Object 构造函数实例化的一个对象 `this instanceof Object //true`
3. 全局对象下有一堆预定义的函数和属性
4. 作为全局变量的宿主 `var a = 1, this.a == 1`，也就是说全局变量最终会挂载到 window 上
5. 客户端 JavaScript 中，全局对象有 window 属性指向自身

```js
var a = 1
console.log(window.a) // 1

this.window.b = 2
console.log(this.b) // 2
```

**总结**

全局对象满足了已下条件:

1. 全局对象存储了全局上下文中的变量和函数声明 (变量对象)
2. 全局对象作为作用域链中的头 (作用域链)
3. 全局对象 this == window (this)

**结论**

**全局上下文中的变量对象就是全局对象**

我觉得全局上下文就是全局对象, 不排除全局上下文有其他属性

# 函数上下文

1. 函数执行上下文内,变量对象用 **活动变量(activation object, AO)** 来表示
2. 当进入函数执行上下文时，AO 会被创建出来，属性能够被访问
3. 活动对象 == 变量对象， 只是状态不同的，内部属性值能否被访问

# 执行过程(很重要)

1. 进入执行上下文
2. 代码执行

下面的题思考时都需要按照这两步分析才能不出错

# 进入执行上下文

这是 **分析步骤** 代码还没有实际执行

AO 会包括:

1. 函数所有形参(如果是函数上下文)

   - 由名称和对应值组成的一个 AO 的属性被创建
   - 没有实参，属性值设为 undefined

   > 在这步的时候如果有实参，会被赋值的

2. 函数声明

   - 由名称和对应值(函数对象(function-object)) 组成一个 AO 的属性被创建
   - 如果 AO 中已经存在相同的属性，则**完全替换**这个属性

3. 变量声明

   - 由名称和对应值(undefined)组成一个 AO 的属性被创建
   - 如果 AO 中已经声明的形参和函数名称相同， 则变量声明**不会干扰**已经存在的属性

> 优先级 函数声明 > 形参声明 > 变量声明
> 所谓的不干扰 应该就是在 AO 不进行操作

例子 1:

```js
function foo(a) {
	var b = 2
	function c() {}
	var d = function () {}

	b = 3
}

foo(1)
```

在进入执行上下文后, AO 为:

```js
AO = {
    // 初始化就存在的, 已数组形式存在，下面的 0 其实就是索引
    arguments: {
        0: 1 // 传入的参数被赋值
        length: 1
    }
    a: 1 // 声明变量，由于a是形参 并将实参赋值
    b: undefined // 声明变量 用undefined占位
    c: reference to function () {} // 函数, 指向函数引用地址
    d: undefined // 函数表达式写法 当成var = 1 即可，就是变量声明，所以不赋值
}

```

# 代码执行

进入执行阶段会对声明的代码进行赋值

执行结果:

```js
AO = {
    arguments: {
        0: 1
        length: 1
    }
    a: 1
    b: 3
    c: reference to function () {}
    d: reference to FunctionExpression "d"
}

```

**总结**

1. 全局上下文的变量对象初始化就是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参, 函数声明, 变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值

# 思考题

1. 第一题

```js
function foo() {
	console.log(a)
	a = 1
}

foo() // ???

function bar() {
	a = 1
	console.log(a)
}
bar() // ???
```

分析阶段:

```js
// foo
AO = {
	arguments: {
		length: 0
	}

	// 由于 a 未已 var 关键字声明 不会记录到AO中
}

// bar
AO = {
	arguments: {
		length: 0
	}
	// 由于 a 未已 var 关键字声明 不会记录到AO中
}
```

执行阶段:

```js
// foo
// 由于在AO中没有A的声明, 会去全局中找，发现没有 所以 console.log会报错
// 会在全局对象中声明一个a 并且 赋值
a = 1

// bar

// 在 AO 中没有查找到 a 的存在会向上查找
// 发现在全局对象中存在 a, 则会对a 进行赋值
a = 1
```

2. 第二题

```js
console.log(foo)

function foo() {
	console.log("foo")
}

var foo = 1
```

分析阶段:

```js
// 注意这个是在全局上下文
VO = {
    // 函数声明
    foo : reference to function () {}

    // 变量声明， 但是 foo 已经存在了 所以会被忽略掉
    // foo : undefined
}

```

执行阶段:

```js
// 在 VO 中 发现了 foo
// 打印函数体
```
