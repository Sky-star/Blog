## 定义

维基百科中对柯里化(Currying)的定义为:

> In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.

翻译成中文:

在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的技术。

例子:

```js
function add(a, b) {
	return a + b
}

// 执行 add 函数， 一次传入两个参数即可
add(1, 2) // 3

// 假设有一个curry函数可以做到柯里化
var addCurry = curry(add)
addCurry(2)(3)
```

## 用途

例子:

```js
// 示例
function ajax(type, url, data) {
	var xhr = new XMLHttpRequest()
	xhr.open(type, url, true)
	xhr.send(data)
}

// 虽然ajax 这个函数非常通用，但在重复调用的时候参数冗余
ajax("POST", "www.test.com", "name=kevin")
ajax("POST", "www.test2.com", "name=kevin")
ajax("POST", "www.test3.com", "name=kevin")

// 利用 Curry
var ajaxCurry = curry(ajax)

// 以 POST 类型请求数据
var post = ajaxCurry("POST")
post("www.test.com", "name=kevin")

// 以 POST 类型请求来自于 www.test.com 的数据
var postFromTest = post("www.test.com")
postFromTest("name=kevin")
```

curry 的这种用途可以理解为： 参数复用。本质上是降低通用性，提高适用性

如果仅仅是把参数一个一个传进去，意义可能不大，但是如果把柯里化后的函数传给其他函数比如 map 呢？

例子:

正常获取 person 中的 name，可以这么做

```js
var person = [{ name: "kevin" }, { name: "daisy" }]
var name = person.map(function (item) {
	return item.name
})
```

如果有 curry 函数:

```js
var prop = curry(function (key, obj) {
	return obj[key]
})

var name = person.map(prop("name"))
```

为了获取 name 属性，还需要再编写一个 prop 函数，看起来有些麻烦。

但是 prop 函数编写一次后，可以多次使用，实际上代码从原本的三行精简成了一行，而且代码更加易懂了。

`person.map(prop("name"))`语义化: person 对象遍历(map)获取(prop) name 属性

## 第一版

思路： 可以利用闭包的特性，将传入的参数保存起来，等到执行调用的时候，将之前保存的参数一起塞进去然后执行

一个经常看到的 curry 函数的实现为:

```js
var curry = function (fn) {
	var args = [].slice.call(arguments, 1)
	return function () {
		var newArgs = args.concat([].slice.call(arguments))
		return fn.apply(this, newArgs)
	}
}
```

可以这样使用:

```js
function add(a, b) {
	return a + b
}

var addCurry = curry(add, 1, 2)
addCurry() // 3

var addCurry = curry(add, 1)
addCurry(2) // 3

var addCurry = curry(add)
addCurry(1, 2) // 3
```

已经有点柯里化的感觉了，还有点小瑕疵像`arrCurry(1)(2)就不行了`,但是可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数

## 第二版

```js
function sub_curry(fn) {
	var args = [].slice.call(arguments, 1)
	return function () {
		return fn.apply(this, args.concat([].slice.call(arguments)))
	}
}

function curry(fn, length) {
	// 获取函数参数长度
	length = length || fn.length

	var slice = Array.prototype.slice

	return function () {
		// 判断执行函数时传入的参数长度是否小于 fn 定义的形参长度
		if (arguments.length < length) {
			var combined = [fn].concat(slice.call(arguments))
			return curry(sub_curry.apply(this, combined), length - arguments.length)
		}
		// 当陆续传入的参数与fn定义的形参长度相同时，执行函数
		else {
			return fn.apply(this, arguments)
		}
	}
}
```

验证下函数:

```js
var fn0 = function (a, b, c) {
	return [a, b, c]
}

var fn = curry(fn0)

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

分步骤解析下`fn("a","b")("c")("d")`

1. 当执行`fn("a","b")`时

```js
fn("a", "b")
// 相当于
curry(fn0)("a", "b")
// 相当于
curry(sub_curry(fn0, "a", "b"))
// 相当于
// 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为fn0后面的参数传入
curry(function(...) {
	return fn0("a","b",...)
})
```

2. 当执行 `fn("a","b")("c")`时，函数返回

```js
curry(sub_curry(function(...) {
	return fn0("a","b",...)
}),"c")

// 相当于
curry(function(...){
	return (function(...){ return fn0("a","b",...)})("c")
})
// 相当于
curry(function(...) {
	return fn0("a","b","c")
})
```

3. 当执行 `fn("a","b""c")`时， 此时`arguments.length < length` 为 false,执行`fn(arguments)` 相当于

```js
(function(...){
	return fn0("a","b","c",...)
})("d")
// 相当于
fn0("a","b","c","c")
```

4. 函数执行结束

整体思路其实很好理解：

sub_curry 的作用就是函数包裹原函数，然后给原函数传入之前的参数。这时原函数并不执行，当执行`fn0(...)(...)`的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 在包裹原函数,然后将新的参数混合旧的参数传入原函数，直到函数参数的数目达到要求为止

## 更易懂的实现

```js
function curry(fn, args) {
	var length = fn.length

	args = args || []

	return function () {
		var _args = args.slice(0),
			arg,
			i
		for (i = 0; i < arguments.length; i++) {
			arg = arguments[i]
			_args.push(arg)
		}
		if (_args.lengths < length) {
			return curry.call(this, fn, _args)
		} else {
			return fn.apply(this, _args)
		}
	}
}

var fn = curry(function (a, b, c) {
	console.log([a, b, c])
})

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

区别就在于函数参数的拼接
