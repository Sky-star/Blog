## 定义

维基百科中对柯里化(Currying)的定义为:

> In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.

翻译成中文:

在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的技术。

例子:

```js
function add(a, b) {
	return a + b
}

// 执行 add 函数， 一次传入两个参数即可
add(1, 2) // 3

// 假设有一个curry函数可以做到柯里化
var addCurry = curry(add)
addCurry(2)(3)
```

## 用途

例子:

```js
// 示例
function ajax(type, url, data) {
	var xhr = new XMLHttpRequest()
	xhr.open(type, url, true)
	xhr.send(data)
}

// 虽然ajax 这个函数非常通用，但在重复调用的时候参数冗余
ajax("POST", "www.test.com", "name=kevin")
ajax("POST", "www.test2.com", "name=kevin")
ajax("POST", "www.test3.com", "name=kevin")

// 利用 Curry
var ajaxCurry = curry(ajax)

// 以 POST 类型请求数据
var post = ajaxCurry("POST")
post("www.test.com", "name=kevin")

// 以 POST 类型请求来自于 www.test.com 的数据
var postFromTest = post("www.test.com")
postFromTest("name=kevin")
```

curry 的这种用途可以理解为： 参数复用。本质上是降低通用性，提高适用性

如果仅仅是把参数一个一个传进去，意义可能不大，但是如果把柯里化后的函数传给其他函数比如 map 呢？

例子:

正常获取 person 中的 name，可以这么做

```js
var person = [{ name: "kevin" }, { name: "daisy" }]
var name = person.map(function (item) {
	return item.name
})
```

如果有 curry 函数:

```js
var prop = curry(function (key, obj) {
	return obj[key]
})

var name = person.map(prop("name"))
```

为了获取 name 属性，还需要再编写一个 prop 函数，看起来有些麻烦。

但是 prop 函数编写一次后，可以多次使用，实际上代码从原本的三行精简成了一行，而且代码更加易懂了。

`person.map(prop('name'))`语义化: person 对象遍历(map)获取(prop) name 属性

## 第一版

思路： 可以利用闭包的特性，将传入的参数保存起来，等到执行调用的时候，将之前保存的参数一起塞进去然后执行

一个经常看到的 curry 函数的实现为:

```js
var curry = function (fn) {
	var args = [].slice.call(arguments, 1)
	return function () {
		var newArgs = args.concat([].slice.call(arguments))
		return fn.apply(this, newArgs)
	}
}
```

可以这样使用:

```js
function add(a, b) {
	return a + b
}

var addCurry = curry(add, 1, 2)
addCurry() // 3

var addCurry = curry(add, 1)
addCurry(2) // 3

var addCurry = curry(add)
addCurry(1, 2) // 3
```

已经有点柯里化的感觉了，还有点小瑕疵像`arrCurry(1)(2)就不行了`,但是可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数

## 第二版

```js
function sub_curry(fn) {
	var args = [].slice.call(arguments, 1)
	return function () {
		return fn.apply(this, args.concat([].slice.call(arguments)))
	}
}

function curry(fn, length) {
	// 获取函数参数长度
	length = length || fn.length

	var slice = Array.prototype.slice

	return function () {
		// 判断执行函数时传入的参数长度是否小于 fn 定义的形参长度
		if (arguments.length < length) {
			var combined = [fn].concat(slice.call(arguments))
			return curry(sub_curry.apply(this, combined), length - arguments.length)
		}
		// 当陆续传入的参数与fn定义的形参长度相同时，执行函数
		else {
			return fn.apply(this, arguments)
		}
	}
}
```

验证下函数:

```js
var fn = curry(function (a, b, c) {
	return [a, b, c]
})

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

函数这样写有点难以理解,解释下面这段的执行过程

```js
function foo(a, b, c) {
	return [a, b, c]
}

var fn = curry(foo)
fn("a")("b")("c") // ["a", "b", "c"]
```

1. curry 函数执行, 得到 length 长度为 3

```js
function curry(foo) {
	length = foo.length = 3

    return function() {
        ...
    }
}
```

2. 执行`fn("a")`, `curry`内部的匿名函数被执行, `arguments.length(1) < length(3)`，if 内的语句被执行

```js
function () {

}
```
