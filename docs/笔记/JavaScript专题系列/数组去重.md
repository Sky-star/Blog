# 双层循环

最原始的方法: 不适用数组的 API

```js
var array = [1, 1, "1", "1"]
function unique(array) {
	var res = []
	for (var i = 0; i < array.length; i++) {
		for (var j = 0; j < res.length; j++) {
			if (array[i] === res[j]) {
				break
			}
		}

		// 如果array[i] 是唯一的，那么循环完成 j 就会等于 res.length
		if (j === res.length) {
			res.push(array[i])
		}
	}

	return res
}

console.log(unique(array)) // [1, "1"]
```

在这个方法中，我们使用循环嵌套，最外层循环 array，里面循环 res，如果 array[i] 的值跟 res[j] 的值相等，就跳出新婚，如果都不等于，就说明元素是唯一的，这时候 j 的值就会等于 res 的长度。

> 这个方法兼容性最好，因为没用啥新的 API

# indexOf

用`indexOf`函数来简化内层循环

```js
var array = [1, 1, "1", "1"]
function unique(array) {
	var res = []
	for (var i = 0; i < array.length; i++) {
		var current = array[i]
		if (res.indexOf(current) === -1) {
			res.push(array[i])
		}
	}
	return res
}

console.log(unique(array)) // [1, "1"]
```

# 排序后去重

将要一个需要去重的数组进行**排序**后, 相同的值会被排在一起， 就可以判断当前元素与上一个元素是否相同，形同就说明重复， 不相同就添加进 res。

> 对于复杂类型的数组排序方法很关键， 一个不小心可能就会导致排序的结果与预期不符，导致去重失败

```js
var array = [1, 1, "1", "1"]
function unique(array) {
	var res = []
	// 这里使用 concat, 会返回一个不影响原数组的数组
	var sortedArray = array.concat().sort()
	var seen
	for (var i = 0; i < sortedArray.length; i++) {
		// 如果是第一个元素或者相邻的元素不相同
		if (!i || seen !== sortedArray[i]) {
			res.push(sortedArray[i])
		}

		seen = sortedArray[i]
	}
	return res
}

console.log(unique(array)) // [1, "1"]
```

# unique API

尝试写一个`unique`工具函数， 根据传入的参数`isSorted`判断传入的数组是否已经排序好的，如果为 `true`， 就判断相邻元素是否相同，如果为 `false`， 就使用`indexOf`判断

```js
var array1 = [1, 2, "1", 2, 1]
var array2 = [1, 1, "1", 2, 2]

function unique(array, isSorted) {
	var res = []
	var seen

	for (var i = 0; i < array.length; i++) {
		var value = array[i]
		if (isSorted) {
			if (!i || seen !== value) {
				res.push(value)
			}

			seen = value
		} else if (res.indexOf(value) === -1) {
			res.push(value)
		}
	}

	return res
}

console.log(unique(array1)) // [1, 2, "1"]
console.log(unique(array2, true)) // [1, "1", 2]
```

# 优化

在上面的基础上添加新的需求: 忽略字母的大小写， 也就是`a` 与 `A` 一致， 保留一个就行

方法 1:

- 将数组中所有的字母转为小写， 再进行去重。 缺点是遍历了两遍

方法 2:

- 直接在去重的循环中处理好数据。 外层循环只一次即可

```js
var array3 = [1, 1, "a", "A", 2, 2]

function unique(array, isSorted, iteratee) {
	var res = []
	var seen = []
	for (var i = 0; i < array.length; i++) {
		var value = array[i]
		var computed = iteratee ? iteratee(value, i, array) : value
		if (isSorted) {
			if (!i || seen !== computed) {
				res.push(value)
			}

			seen = computed
		} else if (iteratee) {
			if (seen.indexOf(computed) === -1) {
				seen.push(computed)
				res.push(value)
			}
		} else if (res.indexOf(value) === -1) {
			res.push(value)
		}
	}

	return res
}

console.log(
	unique(array3, false, function (item) {
		return typeof item == "string" ? item.toLowerCase() : item
	})
) // [1, "a", 2]
```

> 函数内部的 seen 根据传参不同类型也不同， 当`isSorted`为`true`时， seen 的类型是数组内元素的类型， 当`iteratee`参数存在时， seen 的类型是数组，用于存储数组元素变化后的结果

函数参数作用:
array: 表示要去重的数组, 必填
isSorted: 表示函数传入的数组是否已排过序,如果为 true，将会采用更快的方法进行排序
iteratee: 将需要处理的元素移交到外部去处理，降低函数内部的耦合

# filter
