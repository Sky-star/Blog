# 前言

在开发中，我们经常会遇到在数组中查找元素的要求，可能大家觉得这个需求过于简单，然而如何优雅的去实现一个`findIndex`、`findLastIndex`、`indexOf`和`lastIndexOf`方法却是很少有人思考的的。本文就是一起参考着 underscore 去实现这些方法。

在实现前，先看看 ES6 的`findIndex`方法，了解`findIndex`的使用方法。

## ES6 中的 findIndex

ES6 对数组新增了 findIndex 方法，它会返回数组中满足提供的函数的第一个元素的索引，否则返回-1

```js
function isBigEnough(element) {
	return element >= 15
}

;[12, 5, 8, 130, 44].finIndex(isBigEnough) // 3
```

findIndex 会找出第一个大于 15 的元素的下标，所以最后返回 3

## 实现 findIndex

思路：遍历一遍将满足要求的值的下标返回即可

```js
function findIndex(array, predicate, context) {
	for (var i = 0; i < array.length; i++) {
		if (predicate.call(context, array[i], i, array)) return i
	}

	return -1
}

console.log(
	findIndex([1, 2, 3, 4], function (item, i, array) {
		if (item === 3) return true
	})
)
```

解释下参数:

- array: 需要查找的数组
- predicate: 筛选的方法
- context: 需要传入的上下文，也就是 this 的指向。默认是 window

## 实现 findLastIndex

findIndex 是正序查找，那么 findLastIndex 是倒序查找。 实现思路很简单，从后向前遍历即可

```js
function findIndex(array, predicate, context) {
	for (var i = array.length - 1; i >= 0; i--) {
		if (predicate.call(context, array[i], i, array)) return i
	}

	return -1
}
```

## createIndexFinder

通过上面的两个方法，发现代码有很多相同的地方，唯一的不同是循环的方向不同。

underscore 的思路就是利用传参的不同，返回不同的函数。 难点在于如何在一个循环中，如何根据参数的不同来实现正序遍历和倒序遍历。

模仿 underscore 中的实现:

```js
function createIndexFinder(dir) {
	return function (array, predicate, context) {
		var length = array.length
		// 确定遍历的起始位置
		var index = dir > 0 ? 0 : length - 1

		// 精髓的地方，只需要确保index不越界，索引值的增加与减少由外部变量控制
		for (; index >= 0 && index < length; index += dir) {
			if (predicate.call(context, array[index], index, array)) return index
		}
		return -1
	}
}

var findIndex = createIndexFinder(1)
var findLastIndex = createIndexFinder(-1)
```

需要注意的地方有两个:

- dir 的取值只能是`1`或`-1`
- 循环中的边界问题,以及索引值的变化由 dir 控制

## sortedIndex

方法效果: 在一个排序号的数组中找到 value 对应的位置，保证插入数组后，依然保持有序的状态

示例:

```js
sortedIndex([10, 20, 30], 25) // 2
```

实现思路: 重点在与查找方法，因为是有序数组，所以可以使用二分查找法

```js
function sortedIndex(array, obj) {
	var low = 0,
		high = array.length

	while (low < high) {
		var mid = Math.floor((low + high) / 2)
		if (array[mid] < obj) low = mid + 1
		else high = mid
	}

	return high
}

console.log(sortedIndex([10, 20, 30, 40, 50], 35)) // 3
```

虽然这个方法能够使用，但是通用性不够，只能处理一些比较简单的数据。比如我们希望能处理这样的情况：

```js
var stooges = [
	{ name: "stooge1", age: 10 },
	{ name: "stooge2", age: 30 }
]

var result = sortedIndex(stooges, { name: "stooge3", age: 20 }, function (stooge) {
	return stooge.age
})

console.log(result) // 1
```

所以还需要再加一个参数 iteratee 函数对数组的每一个元素进行处理，一般这个时候， 还会涉及到 this 指向的问题，所以可以再传一个 context 来让我们可以指定 this。

```js
// 辅助方法,处理this指向问题
function cb(func, context) {
	if (context === void 0) return func

	// 用匿名函数包裹是为了apply不立即执行
	return function () {
		return func.apply(context, arguments)
	}
}

function sortedIndex(array, obj, iteratee, context) {
	iteratee = cg(iteratee, context)
	var low = 0,
		high = array.length
	while (low < high) {
		var mid = Math.floor((low + high) / 2)
		if (iteratee(arr[mid]) < iteratee(obj)) low = mid + 1
		else high = mid
	}

	return high
}
```

::: warning
这里二分查找法只能针对升序数组有效
:::

## indexOf

参照 findIndex 和 findLastIndex 的方式，写一个 indexOf 和 lastIndexOf 函数

```js
function createIndexOfFinder(dir) {
    return function(array,item) {
        var length = array.length
        var index = dir> 0: 0: length -1
        for(; index >= 0 && index < length; index += dir) {
            if(array[index] === item) return index
        }
        return -1
    }
}

var indexOf = createIndexOfFinder(1)
var lastIndexOf = createIndexOfFinder(-1)

var result = indexOf([1,2,3,4,5],2)

console.log(result) // 1
```

## fromIndex

数组的 indexOf 方法可以多传递一个参数 fromIndex, 从 MDN 中看到 fromIndex 的解释:

> 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找，以此类推。注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于 0，则整个数组都将会被查询。其默认值为 0。

lastIndexOf 函数中的 fromIndex 在 MDN 的解释:

> 从此位置开始逆向查找。默认为数组的长度减 1(arr.length - 1)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。

按照上面的规则写第二版的方法

```js
function createIndexOfFinder(dir) {
	return function (array, item, idx) {
		var length = array.length
		var i = 0

		// 最终要确保其实的idx要在数组下标的范围之内
		if (typeof idx === "number") {
			if (dir > 0) {
				i = idx > 0 ? idx : Math.max(length + idx, 0)
			} else {
				i = idx >= 0 ? Math.min(length + idx, length) : idx + length + 1
			}
		}

		for (idx >= 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
			if (array[idx] === item) return idx
		}

		return -1
	}
}

var indexOf = createIndexOfFinder(1)
var lastIndexOf = createIndexOfFinder(-1)
```

## 优化

到此为止，已经很接近原生的 indexOf 函数了， 但是 underscore 在此基础上还做了两点优化。

第一个优化是支持查找 NaN

因为`NaN !== NaN`结果为`true`，所以原生的 indexOf 并不能找出 NaN 的下标

```js
;[1, NaN].indexOf(NaN) // -1
```

```js
// 第三版
function createIndexOfFinder(dir, predicate) {

    return function(array, item, idx){

        if () { ... }

        // 判断元素是否是 NaN
        if (item !== item) {
            // 在截取好的数组中查找第一个满足isNaN函数的元素的下标
            idx = predicate(array.slice(i, length), isNaN)
            return idx >= 0 ? idx + i: -1;
        }

        for () { ... }
    }
}

var indexOf = createIndexOfFinder(1, findIndex);
var lastIndexOf = createIndexOfFinder(-1, findLastIndex);
```

第二个优化是支持对有序的数组进行更快的二分查找。

如果 indexOf 第三个参数不传开始搜索的下标值，而是一个布尔值 true, 就认为数组是一个排好序的数组，这时候就会采用更快的二分法进行查找， 这个时候，可以利用写的 sortedIndex 函数。

最终源码:

```js
// 第四版
function createIndexOfFinder(dir, predicate, sortedIndex) {
	return function (array, item, idx) {
		var length = array.length
		var i = 0

		if (typeof idx == "number") {
			if (dir > 0) {
				i = idx >= 0 ? idx : Math.max(length + idx, 0)
			} else {
				length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1
			}
		} else if (sortedIndex && idx && length) {
			idx = sortedIndex(array, item)
			// 如果该插入的位置的值正好等于元素的值，说明是第一个符合要求的值
			return array[idx] === item ? idx : -1
		}

		// 判断是否是 NaN
		if (item !== item) {
			idx = predicate(array.slice(i, length), isNaN)
			return idx >= 0 ? idx + i : -1
		}

		for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
			if (array[idx] === item) return idx
		}
		return -1
	}
}

var indexOf = createIndexOfFinder(1, findIndex, sortedIndex)
var lastIndexOf = createIndexOfFinder(-1, findLastIndex)
```

需要注意的是： 在 underscore 的实现中，只有 indexOf 是支持有序数组使用二分查找，lastIndexOf 并不支持。因为二分查找只能对升序的数组进行快速查找。
