# 前言

响应式系统是 Vue.js 的重要组成部分。mini-vue 的实现要从这里开始

## 响应式数据与副作用函数

副作用函数: 顾名思义，就是会产生副作用的函数

```js
function effect() {
	document.body.innerText = "hello vue3"
}
```

具体解释下，就是 effect 函数执行的时候，会设置 body 的文本内容，但是**除了 effect 函数之外的任何函数都可以读取或者设置 body 的文本内容**。也就是说 effect 函数的执行会直接或间接的影响其他函数的执行，这时就说 effect 函数产生了副作用。 最简单的副作用就是函数内部修改了全局变量。

副作用函数的定义说完，接下来说下响应式数据，假设在一个副作用函数中读取了某个对象的属性:

```js
const obj = {
	text: "hello world"
}
function effect() {
	// effect函数的执行会读取obj.text
	document.body.innerText = obj.text
}
```

上面的代码中，effect 函数中设置了 body.innerText，其值为 obj.text,当 obj.text 的值发生的变化的时候，希望副作用函数 effect 函数会重新执行:

```js
obj.text = "hello vue3"
```

这句代码修改了字段 obj.text 的值，我们希望当值变化后，effect 函数能够自动执行，如果能够实现这个目标， 那么对象 obj 就是响应式数据。那么就需要一种能够监听对象属性变化的手段来让 effect 函数自动执行

## 响应式数据的基本实现

能够监听对象属性的变化有两种:

- vue2 种使用 Object.defineProperty 函数实现
- vue3 种使用 Proxy 实现

这里采用 Proxy 的方式实现

实现思路: 在读取对象属性时，将 effect 函数放入到一个带执行容器中，这样 effect 函数就被保存起来了，在设置这个对象的属性时，将容器中的 effect 函数取出来执行

```js
// 存储副作用函数的容器
const bucket = new Set()

// 原始数据
const data = { data: "hello world" }
// 对原始数据的代理
const proxy = new Proxy(data, {
	// 拦截读取操作
	get(target, key) {
		// 将副作用函数存入到容器中
		bucket.add(effect)
		// 返回属性值
		return target[key]
	},
	// 拦截设置操作
	set(target, key, value) {
		// 设置属性值
		target[key] = value
		// 把副作用函数从容器中取出并执行
		bucket.forEach((fn) => fn())
		// 返回true 代表设置操作成功
		return true
	}
})
```

实现步骤:

1. 创建一个用于存储副作用函数的容器 bucket，用 Set 类型，防止重复存储
2. 接着定义原始数据 data, proxy 是原始数据的代理对象，分别设置了 get 和 set 拦截函数，用于拦截设置和读取操作
3. 当拦截读取操作时，将副作用函数存入到 bucket 中
4. 当拦截设置操作时，遍历 bucket，执行副作用函数

测试代码如下

```js
// 副作用函数
function effect() {
	document.body.innerText = proxy.text
}
// 执行辅佐用函数，触发读取
effect()
// 1 秒后修改响应式数据
setTimeout(() => {
	proxy.text = "hello vue3"
}, 1000)
```

这样响应式数据的基本实现和工作原理就讲完了，但是这个实现还有很多缺陷的

1. 在 get 拦截函数中，直接通过副作用函数名称(effect)来获取副作用函数,硬编码的方式非常不灵活
2. 触发读取需要手动执行
