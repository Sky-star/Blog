# 前言

上一节中，我们完善了响应式系统的设计，这其中还有一些问题需要处理

## 分支切换

看下面这段代码:

```js
const data = { ok: true, text: "hello world" }

const obj = new Proxy(data, {
	/* ... */
})

effect(function effectFn() {
	document.body.innerText = obj.ok ? obj.text : "not"
})
```

在 effectFn 内部存在一个三元表达式， 根据字段 obj.ok 值的不同会执行不同的代码分支。当字段 obj.ok 的值发生变化时， 代码执行的分支会跟着变化， 这就是所谓的分支切换

那么问题来了,分支切换可能会产生遗留的副作用函数！

拿上面这段代码来说，字段的 obj.ok 的值为 true，这时会读取 obj.text 的值，所以当 effectFn 执行时会触发 obj.ok 和 obj.text 两个属性的读取操作, 此时副作用函数 effectFn 与响应式数据之间建立的联系如下:

```js
 data
     └── ok
         └── effectFn
     └── text
         └── effectFn
```

可以看到， 副作用函数 effectFn 分别被字段 data.ok 和 data.text 所对应的依赖集合收集。 当字段 obj.ok 的值修改为 false，并触发副作用函数重新执行后， 由于此时字段 obj.text 的值不会被读取，只会触发 obj.ok 的读取操作， 所以理想情况下副作用函数 effectFn 不应该被字段 obj.text 所对应的依赖集合收集。理想情况下副作用函数与响应式数据之间的联系如下:

```js
 data
     └── ok
         └── effectFn
```

但是按照上一篇的实现,还暂时做不到这一点。 也就是说，当我们把字段 obj.ok 的值修改为 false，并触发副作用函数执行后，整个依赖关系并没有发生变化,这时就产生了遗留的副作用函数

遗留的副作用函数会导致不必要的更新, 拿下面这段代码来说:

```js
const data = { ok: true, text: "hello world" }
const obj = new Proxy(data, {
	/* ... */
})

effect(function effectFn() {
	document.body.innerText = obj.ok ? obj.text : "not"
})
```

obj.ok 的初始值为 true，当将其修改为 false 后:

```js
obj.ok = false
```

这会触发更新，即副作用函数会重新执行。 但由于此时 obj.ok 的值为 false， 所以不再会读取 obj.text 的值。 换句话说，无论字段 obj.text 的值如何变化，document.body.innerText 的值始终都是字符串'not'。 所以期望的结果是，不论 obj.text 的值如何变化，都不需要重新执行副作用函数。但是事实并非如此， 如果尝试修改 obj.text 的值:

```js
obj.text = "hello vue3"
```

这仍然会执行导致副作用函数重新执行，即使 document.body.innerText 的值不需要变化。

## cleanup

解决这个问题的思路很简单，每次副作用函数执行的时候，可以先把它从所有与之关联的依赖集合中删除。如下所示

```js
 data
     └── ok
         └── 依赖集合 (删除effectFn)
     └── text
         └── 依赖集合 (删除effectFn)
```

当副作用函数执行完毕后，会重新建立联系，但是在新的联系中不会包含遗留的副作用函数。所以，如果能够做到每次副作用函数执行前，将其从相关联的依赖集合中移除，那么问题就解决了。

为了将一个副作用函数从所有与之关联的依赖集合中移出， 就需要明确的知道哪些依赖集合中包含了它。 因此就需要设计新的副作用函数,代码如下

```js
let activeEffect

function effect(fn) {
	// 为了封装性，不能将反向收集的依赖挂载fn上
	const effectFn = () => {
		// 当 effectFn 执行时， 将其设置为当前激活的副作用函数
		activeEffect = effectFn

		fn()
	}

	// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
	effectFn.deps = []

	// 执行副作用函数
	effectFn()
}
```

那么 effectFn.deps 数组中的依赖集合是如何收集的呢？ 其实是在 track 函数中:

```js
function track(target, key) {
	if (!activeEffect) return

	let depsMap = bucket.get(target)

	if (!depsMap) {
		bucket.set(target, (depsMap = new Map()))
	}

	let deps = depsMap.get(key)

	if (!deps) {
		deps.set(key, (deps = new Set()))
	}

	deps.add(activeEffect)

	// deps 就是一个与当前副作用函数存在联系的依赖集合
	// 将deps 添加到 activeEffect.deps中, 完成反向收集
	activeEffect.deps.push(deps)
}
```

在 track 函数中， 将当前执行的副作用函数 activeEffect 添加到依赖集合 deps 中， 说明 deps 就是一个与当前副作用函数存在联系的依赖集合， 于是我们反过来把这个依赖集合添加到 activeEffect.deps 数组中， 这样就完成了对依赖集合的收集工作

完成了反向收集之后，就可以在每次副作用函数执行的时候，根据 effectFn.deps 获取所有与之关联的依赖集合，进而将副作用函数从依赖集合中移除
