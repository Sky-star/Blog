## 总结

在 10 到 17 节中，主要讲解了非原始值的响应式方案，即对象的响应式方案。

### 第十节

我们首先介绍了 Proxy 和 Reflect。Vue.js 3 的响应式数据是基于 Proxy 实现的，Proxy 可以为其他对象创建了一个代理对象。所谓代理，指的是对一个对象**基本语义**的代理。它允许我们拦截并重新定义一个对象的基本操作。在实现代理的过程中，我们遇到了访问器 this 指向的问题，这需要使用 Reflect.\*方法并指定正确的 receiver 来解决。

### 第十一节

详细的讨论了 JavaScript 中对象的概念，以及 Proxy 的工作原理。在 ECMAScript 规范中，JavaScript 中有两种对象，其中一种叫作常规对象，另一种叫作异质对象。满足以下三点要求的对象就是常规对象:

- 对于该节中给出的内部方法，必须使用规范 10.1.x 节给出的定义实现；
- 对于内部方法[[Call]]，必须使用规范 10.21 节中给出的定义实现；
- 对于内部方法[[Construct]],必须使用规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象是异质对象。一个对象是函数还是其他对象，是由部署在该对象上的内部方法和内部槽决定的。

### 第十二节

接着，我们讨论了关于对象 Object 的代理。**代理对象的本质，就是查阅规范并找到可拦截的基本操作的方法。** 有一些操作并不是基本操作，而是符合操作，这需要我们查阅规范了解他们都依赖哪些基本操作，从而通过基本操作的拦截方法简介地处理复合操作。我们还详细分析了添加、修改、删除属性对 for...in 操作的影响，其中添加和删除属性都会影响 for...in 循环的执行次数，所以当这些操作发生时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。而修改属性值则不影响 for...in 循环的执行次数，因此无须处理。

### 第十三节

我们还讨论了如何合理地触发副作用函数重新执行，包括对 NaN 的处理，以及访问原型链上的属性导致副作用函数重新执行两次的问题。对于 NaN，我们主要注意 NaN === NaN 永远等于 false。对于原型链属性问题，需要我们查阅规范定位问题的原因。由此可见，想要基于 Proxy 实现一个相对完善的响应系统，免不了去了解 ECMAScript 规范。

### 第十四节和第十五节

我们讨论了深响应与浅响应，以及深只读与浅只读。这里的深和浅指的是对象的层级，浅响应（或只读）代表仅代理一个对象的第一层属性，即只有对象的第一层属性值是响应(或只读)的。深响应(或只读)恰恰相反，为了实现深响应(或只读)，我们需要在返回属性值之前，对值做一层包装，将其包装为响应式（或只读）数据后再返回。

### 第十六节

我们讨论了关于数组的代理。数组是一个异质对象，因为数组对象部署的内部方法[[DefineOwnProperty]]不同于常规对象。通过索引为数组设置新的元素，可能会隐式地修改数组 length 属性的值。对应地，修改数组 length 属性的值，也可能间接影响数组中的已有元素。所以在触发响应的时候需要额外注意。我们还讨论了如何拦截 for...in 和 for...of 对数组的遍历奥做。使用 for...in 循环遍历数组与遍历普通对象区别不大，唯一需要注意的是，当追踪 for...in 操作时，应该使用数组的 length 作为追踪的 key。for...of 基于迭代协议工作，数组内建了 Symbol.iterator 方法。根据规范 23.1.5.1 节可知，数组迭代器执行时，会读取数组的 length 属性或数组索引。因此，我们不需要做其他额外的处理，就能够实现对 for...of 迭起的响应式支持。

我们还讨论了数组的查找方法。如 includes、indexOf 以及 lastIndexOf 等。对于数组元素的查找，需要注意的一点是，用户级可能使用代理对象进行查找，也可能使用原始对象进行查找。为了支持这两种形式，我们需要重写数组的查找方法。原理很简单，当用户使用这些方法查找元素时，我们可以先去代理对象中查找，如果找不到，再去原始数组中查找。

我们还介绍了隐藏修改数组长度的原型方法，即 push、pop、shift、unshift 以及 splice 等方法。调用这些方法会间接地读取和设置数组的 length 属性，因此，在不同的副作用函数内对同一个数组执行上述方法，会导致多个副作用函数之间循环调用,最终导致调用栈溢出。为了解决这个问题，我们使用一个标记变量 shouldTrack 来代表是否允许进行追踪，然后重写了上述这些方法，目的是，当这些方法间接读取 length 属性时，我们会先将 shouldTrack 的值设置为 false，即禁止追踪。这样就可以断开 length 属性与副作用函数之间的响应联系，从而避免循环调用导致的调用栈溢出。

### 第十七节

最后，我们讨论了关机集合类型数据的响应式方案。集合类型指 Set、Map、WeakSet 以及 WeakMap。我们讨论了使用 Proxy 为集合类型创建代理对象的一些注意事项。结合类型不同于普通对象，它有特定的数据操作方法。当使用 Proxy 代理结合类型的数据时要格外注意，例如，集合类型的 size 属性是一个访问器属性，当通过代理对象访问 size 属性时，由于代理对象本身并没有部署[[SetData]]这样的内部槽，所以会发生错误。另外，通过代理对象执行集合类型的奥做方法时，用注意这些方法执行时的 this 指向，我们需要在 get 拦截函数内通过.bind 函数为这些方法绑定正确的 this 值。

我们还讨论了集合类型响应式数据的实现。我们需要通过“重写”集合方法的方式来实现自定义的能力，当 Set 结合的 add 方法执行时，需要调用 trigger 函数触发响应。

我们也讨论了关于数据污染的问题。数据污染值的是不小心将响应式数据添加到原始数据中，它导致用户可以用过原始数据执行响应式相关操作，这不是我们所期望的。为了避免这类问题发生，我们通过响应式数据对象的 raw 属性来访问对应的原始数据对象，后续操作使用原始数据对象就可以了。

我们还讨论了关于结合类型的遍历，即 forEach 方法。集合的 forEach 方法与对象的 for...in 遍历类似，最大的不同体现在，当使用 for...in 遍历对象时，我们只关心对象的键是否变化，而不关心值；但使用 forEach 遍历集合时，我们即关心键的变化，也关心值的变化。额外的是，Set 类型的 forEach 只关心值的变化，不关心键的变化。
