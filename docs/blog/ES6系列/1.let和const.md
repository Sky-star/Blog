## 块级作用域的出现

通过 var 声明的变量存在变量提升的特性:

```js
if (condition) {
	var value = 1
}

console.log(value)
```

初学者可能会觉得只有 condition 为 true 的时候，才会创建 value，如果 condition 为 false，结果应该是报错，然而因为变量提升的原因，代码相当于:

```js
var value
if (condition) {
	value = 1
}

console.log(value)
```

除此之外，在 for 循环中:

```js
for (var i = 0; i < 10; i++) {}

console.log(i) // 10
```

即便循环已经结束了，依然可以访问 i 的值

为了加强对变量生命周期的控制， ECMAScript5 引入了块级作用域

块级作用域存在于:

- 函数内部

- 块中(字符 { 和 } 之间的区域)

## let 和 const

块级声明用于声明在指定块的作用域之外无法访问的变量

let 和 const 都是块级声明的一种

let 和 const 的特点:

1. 不会被提升

```js
if (false) {
	let value = 1
}

console.log(value) // Uncaught ReferenceError: value is not defined
```

2. 重复声明报错

```js
var value = 1
let value = 2 // Uncaught SyntaxError: Identifier 'value' has already been declared
```

3. 不绑定全局作用域

当在全局作用域中使用 var 声明的时候， 会创建一个新的全局变量作为全局对象的属性

```js
var value = 1
console.log(window.value) // 1
```

然而 let 和 const 不会

```js
let value = 1
console.log(window.value) // undefined
```

let 和 const 的区别:

const 用于声明常量，其值一旦被设定不能再被修改，否则会报错

值得一提的是: const 声明不允许修改绑定，但允许修改值。 这以为着当用 const 声明对象时:

```js
const data = {
	value: 1
}

// 没有问题
data.value = 2
data.num = 3

// 报错
data = {} // Uncaught TypeError: Assignment to constant variable.
```

## 临时死区

临时死区(Temporal Dead Zone), 简写为 TDZ

let 和 const 声明的变量不会被提升到作用域顶部， 如果在声明之间访问这些变量，会导致报错:

```js
console.log(typeof value) // Uncaught ReferenceError: value is not defined
let value = 1
```
